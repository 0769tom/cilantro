#!/usr/bin/env seneca_0.1
## Example currency smart contract ##
# UNITTEST_FLAG_CURRENCY_SENECA 1729

import seneca.storage.tabular as st
import seneca.crypto as crypto
import seneca.runtime as rt
import seneca.stdlib as std
from seneca.modulelib import export, make_exports

ledger = st.create_table('ledger', [
    ('wallet_id', st.str_len(200), True),
    ('balance', int),
])

safe = st.create_table('safe', [
    ('wallet_id', st.str_len(200)),
    ('amount', int),
    ('locked_until', std.datetime),
    ('contract_id', st.str_len(200)) # Name of contract using this safe
])

allowed = st.create_table('allowed', [
    ('from_id', st.str_len(200)),
    ('to_id', st.str_len(200)),
    ('amount', int),
])

@export
def get_balance(wallet_id):
    return ledger.select('balance').where(ledger.wallet_id == wallet_id).run()[0]['balance']


@export
def wallet_exists(wallet_id):
    query = ledger.select('wallet_id').where(ledger.wallet_id == wallet_id)
    return len(query.run()) == 1

@export
def create_wallet(wallet_id):
    assert not wallet_exists(wallet_id), "Wallet already exists"
    ledger.insert([{'wallet_id': wallet_id, 'balance': 0}]).run()


def add_coins(wallet_id, amount_to_add):
    assert amount_to_add >= 0, "It's not possible to 'add' a negative balance"

    if not wallet_exists(wallet_id):
        create_wallet(wallet_id)

    old_balance = get_balance(wallet_id)
    ledger.update({'balance': old_balance + amount_to_add}) \
        .where(ledger.wallet_id == wallet_id).run()


def remove_coins(wallet_id, amount_to_remove):
    assert wallet_exists(wallet_id), "Wallet id is not present in ledger"
    assert amount_to_remove >= 0, "Removing negative balances not permitted"

    old_balance = get_balance(wallet_id)
    assert old_balance - amount_to_remove >= 0, "No negative balances allowed"
    ledger.update({'balance': old_balance - amount_to_remove}) \
        .where(ledger.wallet_id == wallet_id).run()


@export
def transfer_coins(receiver_id, amount):
    sender_id = rt.global_run_data.author
    remove_coins(sender_id, amount)
    add_coins(receiver_id, amount)

@export
def get_approved(from_id, to_id):
    approved = allowed.select().where(allowed.from_id == from_id and allowed.to_id == to_id).run()
    if len(approved) == 1:
        return approved[0]['amount']

@export
def approve(to_id, amount):
    assert amount > 0, 'Cannot approve negative amount'
    from_id = rt.global_run_data.author
    approved_amount = get_approved(from_id, to_id)
    if approved_amount != None:
        approved_amount = approved_amount + amount
        allowed.update({'amount': approved_amount}) \
            .where(allowed.from_id == from_id and allowed.to_id == to_id).run()
    else:
        allowed.insert([{
            'from_id': from_id, 'to_id': to_id, 'amount': amount
        }]).run()

@export
def transfer_coins_from(from_id, to_id, amount):
    approved_amount = get_approved(from_id, to_id)
    assert approved_amount, 'Not approved to transfer'
    assert approved_amount >= amount, 'Attempting to transfer more than approved'
    approved_amount = approved_amount - amount
    allowed.update({'amount': approved_amount}) \
        .where(allowed.from_id == from_id and allowed.to_id == to_id).run()
    remove_coins(from_id, amount)
    add_coins(to_id, amount)

@export
def is_locked(wallet_id):
    contract_id = rt.call_stack[-1][1]
    return safe.select().where(
        safe.wallet_id == wallet_id and \
        safe.contract_id == contract_id
    ).run()

@export
def lock_coins(amount, duration):
    wallet_id = rt.global_run_data.author
    contract_id = rt.call_stack[-1][1]
    assert amount > 0, 'Cannot lock negative amounts'
    assert not is_locked(wallet_id), 'Already locked for "{}"'.format(contract_id)
    assert type(duration) == std.timedelta, 'Must use {} for duration'.format(std.timedelta)
    remove_coins(wallet_id, amount)
    safe.insert([{
        'wallet_id': wallet_id,
        'amount': amount,
        'contract_id': contract_id,
        'locked_until': std.datetime.now()+duration
    }]).run()

@export
def unlock_coins():
    wallet_id = rt.global_run_data.author
    contract_id = rt.call_stack[-1][1]
    locked_obj = is_locked(wallet_id)
    assert len(locked_obj)!=0, 'No coins in the lock "{}"'.format(contract_id)
    amount = locked_obj[0]['amount']
    res = safe.delete().where(
        safe.wallet_id == wallet_id and \
        safe.contract_id == contract_id and \
        safe.locked_until<=std.datetime.now()).run()
    assert res['row_count'] != 0, 'Cannot unlock coin yet'
    add_coins(wallet_id, amount)


exports = make_exports()

if __name__ == '__main__':
    # print("\n\n STARTING CURRENCY CONTRACT MAIN FUNC \n\n")

    GENESIS_WALLETS = [
        {
            "wallet": "CARL",
            "amount": 3696947
        },
        {
            "wallet": "DAVIS",
            "amount": 3696947
        },
        {
            "wallet": "324ee2e3544a8853a3c5a0ef0946b929aa488cbe7e7ee31a0fef9585ce398502",
            "amount": 3696947
        },
        {
            "wallet": "a103715914a7aae8dd8fddba945ab63a169dfe6e37f79b4a58bcf85bfd681694",
            "amount": 3696947
        },
        {
            "wallet": "20da05fdba92449732b3871cc542a058075446fedb41430ee882e99f9091cc4d",
            "amount": 3696947
        },
        {
            "wallet": "ed19061921c593a9d16875ca660b57aa5e45c811c8cf7af0cfcbd23faa52cbcd",
            "amount": 3696947
        },
        {
            "wallet": "cb9bfd4b57b243248796e9eb90bc4f0053d78f06ce68573e0fdca422f54bb0d2",
            "amount": 3696947
        }
    ]

    # Seed genesis wallets
    list(map(lambda x: add_coins(x['wallet'], x['amount']), GENESIS_WALLETS))
