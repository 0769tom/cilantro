import seneca.storage.tabular as st
import seneca.storage.kv as kv
import seneca.runtime as rt
import seneca.stdlib as std
from seneca.modulelib import export, make_exports

t_election = st.create_table('election', [
    ('policy_maker_id', st.str_len(30)),
    ('policy_name', st.str_len(64)),
    ('created_ts', std.datetime),
    ('opened_ts', std.datetime),
    ('closed_ts', std.datetime),
    ('expire_on', std.datetime),
    ('status', st.str_len(16))
])

@export
def enum():
    return std.enum('OPENED', 'PASSED', 'NOT_PASSED', 'CANCELLED')

STATUS = enum()

@export
def search_for_election(keyword):
    """
        Search for election based on keywords.
    """
    # return election_id

@export
def get_election(election_id):
    res = t_election.select().where(
        t_election.id==election_id
    ).run()
    if res:
        return res[0]

@export
def create_election(term, value_type, tags=[]):
    assert value_type in std.supported_types, 'value type {} not supported!'.format(value_type)
    assert type(term) == std.timedelta, 'election term must be of type {}'.format(std.timedelta)
    policy_maker_id = rt.global_run_data.author
    policy_name = rt.global_run_data.address
    now = std.datetime.now()
    st.create_table('t_{}'.format(policy_name), [
        ('election_id', st.str_len(30)),
        ('voter_id', st.str_len(30)),
        ('value', value_type)
    ])
    kv.create_kv('kv_{}'.format(policy_name))

    #TODO add tags to KV
    return t_election.insert([{
        'policy_maker_id': policy_maker_id,
        'policy_name': policy_name,
        'opened_ts': now,
        'expire_on': now+term,
        'status': STATUS.OPENED
    }]).run()['last_row_id']

@export
def cast_vote(election_id, value):
    voter_id = rt.global_run_data.author
    policy_name = rt.global_run_data.address
    policy_table = st.get_table('t_{}'.format(policy_name))
    res = t_election.select().where(
        t_election.id==election_id
    ).run()
    if res:
        e = res[0]
        assert int(e['status']) == STATUS.OPENED, 'Cannot vote on elections which are not OPENED'
        assert std.datetime.now() <= e['expire_on'], 'The election has ended, please help by calling "tally_votes()"'
        #TODO change to upsert when implemented
        policy_table.insert([{'election_id': election_id, 'voter_id': voter_id, 'value': value}]).run()

@export
def tally_votes(election_id, processor):
    policy_name = rt.global_run_data.address
    policy_table = st.get_table('t_{}'.format(policy_name))
    policy_kv = kv.get_kv('kv_{}'.format(policy_name))
    results = [r['value'] for r in policy_table.select().where(
        policy_table.election_id == election_id
    ).run()]
    val = processor(results)
    policy_kv.set([('value', val)]).run()
    return val

@export
def pass_election(election_id):
    close_election(election_id, STATUS.PASSED)

@export
def fail_election(election_id):
    close_election(election_id, STATUS.NOT_PASSED)

@export
def cancel_election(election_id):
    close_election(election_id, STATUS.CANCELLED)

def close_election(election_id, status):
    policy_maker_id = rt.global_run_data.author
    assert STATUS[status], 'Not a valid status'
    return t_election.update({
        'closed_ts': std.datetime.now(),
        'status': status,
    }).where(
        t_election.policy_maker_id==policy_maker_id and
        t_election.id==election_id and
        t_election.status==STATUS.OPENED
    ).run()

@export
def get():
    policy_name = rt.global_run_data.address
    policy_kv = kv.get_kv('kv_{}'.format(policy_name))
    return policy_kv.get('value').run()

exports = make_exports()

if __name__ == '__main__':
    pass
