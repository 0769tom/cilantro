import seneca.storage.tabular as st
import seneca.runtime as rt
import seneca.stdlib as std
from seneca.modulelib import export, make_exports

t_election = st.create_table('election', [
    ('policy_maker_id', st.str_len(30)),
    ('policy_name', st.str_len(64)),
    ('created_ts', std.datetime),
    ('opened_ts', std.datetime),
    ('closed_ts', std.datetime),
    ('expire_on', std.datetime),
    ('status', st.str_len(16))
])

@export
def enum():
    return std.enum('OPENED', 'PASSED', 'NOT_PASSED', 'CANCELLED')

STATUS = enum()

@export
def search_for_election(keyword):
    """
        Search for election based on keywords.
    """
    # return election_id

@export
def get_election(election_id):
    return t_election.select().where(
        t_election.id==election_id and
        t_election.status==STATUS.OPENED and
        t_election.expire_on>=std.datetime.now()
    ).run()[0]

@export
def create_election(policy_name, expire_on, tags=[]):
    policy_maker_id = rt.global_run_data.author
    #TODO add tags to KV
    return t_election.insert([{
        'policy_maker_id': policy_maker_id,
        'policy_name': policy_name,
        'opened_ts': std.datetime.now(),
        'expire_on': expire_on,
        'status': STATUS.OPENED
    }]).run()['last_row_id']

@export
def pass_election(election_id):
    close_election(election_id, STATUS.PASSED)

@export
def fail_election(election_id):
    close_election(election_id, STATUS.NOT_PASSED)

@export
def cancel_election(election_id):
    close_election(election_id, STATUS.CANCELLED)

def close_election(election_id, status):
    policy_maker_id = rt.global_run_data.author
    assert STATUS[status], 'Not a valid status'
    return t_election.update({
        'closed_ts': std.datetime.now(),
        'status': status,
    }).where(
        t_election.policy_maker_id==policy_maker_id and
        t_election.election_id==election_id and
        t_election.status==STATUS.OPENED
    ).run()

exports = make_exports()

if __name__ == '__main__':
    pass
