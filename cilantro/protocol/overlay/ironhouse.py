#!/usr/bin/env python

"""
Generate client and server CURVE certificate files then move them into the
appropriate store directory, private_keys or public_keys. The certificates
generated by this script are used by the stonehouse and ironhouse examples.
In practice this would be done by hand or some out-of-band process.
Author: Chris Laws
"""

import os, shutil, hashlib, datetime
import asyncio, zmq
import zmq.auth, zmq.asyncio
from zmq.auth.thread import ThreadAuthenticator
from zmq.auth.asyncio import AsyncioAuthenticator
from zmq.utils.z85 import decode, encode
from nacl.public import PrivateKey
from nacl.signing import SigningKey
from nacl.bindings import crypto_sign_ed25519_sk_to_curve25519

from cilantro.logger import get_logger

log = get_logger(__name__)

class Ironhouse:
    def __init__(self, sk=None, auth_payload=b'ack', auth_callback=None, private_key=None, wipe_certs=False, *args, **kwargs):
        self.auth_port = os.getenv('AUTH_PORT', 4523)
        self.keyname = os.getenv('HOSTNAME', os.path.splitext(__file__)[0])
        self.base_dir = 'certs/{}'.format(self.keyname)
        self.keys_dir = os.path.join(self.base_dir, 'certificates')
        self.public_keys_dir = os.path.join(self.base_dir, 'public_keys')
        self.secret_keys_dir = os.path.join(self.base_dir, 'private_keys')
        self.secret_file = os.path.join(self.secret_keys_dir, "{}.key_secret".format(self.keyname))
        self.auth_payload = auth_payload
        self.auth_callback = auth_callback
        self.wipe_certs = wipe_certs
        self.generate_certificates(private_key=private_key, sk=sk)

    def load_keys(self):
        return zmq.auth.load_certificate(self.secret_file)

    def generate_certificates(self, private_key=None, sk=None):
        if sk:
            sk = SigningKey(seed=bytes.fromhex(sk))
            self.vk = sk.verify_key.encode().hex()
            private_key = crypto_sign_ed25519_sk_to_curve25519(sk._signing_key).hex()

        for d in [self.keys_dir, self.public_keys_dir, self.secret_keys_dir]:
            if self.wipe_certs and os.path.exists(d):
                shutil.rmtree(d)
            os.makedirs(d, exist_ok=True)

        if self.wipe_certs:
            if private_key:
                self.create_from_private_key(private_key)
            else:
                client_public_file, client_secret_file = zmq.auth.create_certificates(self.keys_dir, self.keyname)

            # move public keys to appropriate directory
            for key_file in os.listdir(self.keys_dir):
                if key_file.endswith(".key"):
                    shutil.move(os.path.join(self.keys_dir, key_file),
                                os.path.join(self.public_keys_dir, '.'))

            # move secret keys to appropriate directory
            for key_file in os.listdir(self.keys_dir):
                if key_file.endswith(".key_secret"):
                    shutil.move(os.path.join(self.keys_dir, key_file),
                                os.path.join(self.secret_keys_dir, '.'))

            log.info('Generated CURVE certificate files!')

    def create_from_private_key(self, private_key):
        priv = PrivateKey(bytes.fromhex(private_key))
        publ = priv.public_key
        self.public_key = public_key = encode(publ._public_key)
        secret_key = encode(priv._private_key)

        base_filename = os.path.join(self.keys_dir, self.keyname)
        secret_key_file = "{0}.key_secret".format(base_filename)
        public_key_file = "{0}.key".format(base_filename)
        now = datetime.datetime.now()

        zmq.auth.certs._write_key_file(public_key_file,
                        zmq.auth.certs._cert_public_banner.format(now),
                        public_key)

        zmq.auth.certs._write_key_file(secret_key_file,
                        zmq.auth.certs._cert_secret_banner.format(now),
                        public_key,
                        secret_key=secret_key)

    def secure_context(self, loop=None, async=False):
        if async:
            ctx = zmq.asyncio.Context()
            auth = AsyncioAuthenticator(ctx)
        else:
            ctx = zmq.Context()
            auth = ThreadAuthenticator(ctx)
        auth.start()
        auth.configure_curve(domain='*', location=self.public_keys_dir)

        return ctx, auth

    def secure_socket(self, sock, curve_serverkey=None, ip=None):
        public, secret = self.load_keys()
        sock.curve_secretkey = secret
        sock.curve_publickey = public
        if curve_serverkey: sock.curve_serverkey = curve_serverkey
        else: sock.curve_server = True
        return sock

    def authenticate(self, target_public_key, ip):
        # log.debug('{} --> {}'.format(target_public_key, ip))
        # return True
        if ip == os.getenv('HOST_IP'): return True
        client = self.ctx.socket(zmq.REQ)
        client = self.secure_socket(client, target_public_key, ip)
        client.connect('tcp://{}:{}'.format(ip, self.auth_port))
        client.send(os.getenv('PEPPER', 'cilantro').encode('utf-8'))
        authorized = False

        if client.poll(1000):
            msg = client.recv()
            log.debug('got secure reply {}'.format(msg))
            authorized = self.auth_callback(msg) if self.auth_callback else msg
        client.close()
        return authorized

    def setup_secure_server(self):
        self.ctx, auth = self.secure_context()
        self.auth_port = os.getenv('AUTH_PORT', 4523)
        self.sec_sock = self.secure_socket(self.ctx.socket(zmq.REP))
        self.sec_sock.bind('tcp://*:{}'.format(self.auth_port))
        asyncio.ensure_future(self.secure_server())

    async def secure_server(self):
        log.info('Listening to secure connections at {}'.format(self.auth_port))
        while True:
            try:
                message = self.sec_sock.recv(flags=zmq.NOBLOCK)
                log.debug('got secure request {}'.format(message))
                if message.decode() == os.getenv('PEPPER', 'cilantro'):
                    if callable(self.auth_payload): msg = self.auth_payload()
                    else: msg = self.auth_payload
                    self.sec_sock.send(msg)
            except Exception as e: pass
            await asyncio.sleep(0.1)

if __name__ == '__main__':
    Ironhouse(private_key='3f408ce9eb642ecb117b3a435afca260a50badbabbde72b73854ac10289d1022')
